<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Sign Orang Dynasty Arcade Maze Game</title>
  <style>
    :root{
      --orange:#ff7a00;
      --orange2:#ff9a2b;
      --deep:#0c0c0f;
      --ui:#1a1a1f;
      --text:#fff8ef;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:#000;color:var(--text);font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    #game-wrap{position:relative;height:100vh;width:100vw;background:#000;overflow:hidden}

    canvas{background:#000;display:block;max-width:100vw;max-height:100vh;position:absolute}

    /* HUD */
    #hud{
      position:absolute;left:0;right:0;top:0;padding:8px 12px;
      display:flex;gap:12px;align-items:center;justify-content:space-between;
      pointer-events:none;font-weight:600;letter-spacing:.4px;
      text-shadow:0 1px 0 rgba(0,0,0,.3);z-index:4
    }
    .pill{
      background:linear-gradient(180deg,var(--orange2),var(--orange));
      color:#180d00;border-radius:999px;padding:6px 12px;box-shadow:0 2px 12px rgba(255,122,0,.35);
      pointer-events:auto
    }
    .hud-right{display:flex;gap:8px}

    /* Overlays */
    .overlay{
      position:absolute;inset:0;background:
        radial-gradient(1200px 800px at 70% -20%, rgba(255,140,0,.15), transparent 60%),
        radial-gradient(1000px 700px at 20% 120%, rgba(255,100,0,.15), transparent 60%),
        #050507e6;
      display:flex;align-items:center;justify-content:center;padding:24px;z-index:5
    }
    .card{
      width:min(960px,94vw);
      background:linear-gradient(180deg,#111217 0%, #0b0c10 100%);
      border:1px solid rgba(255,122,0,.35);
      border-radius:18px;padding:28px 24px;color:var(--text);
      box-shadow:0 12px 60px rgba(255,122,0,.15), 0 2px 0 rgba(255,255,255,.02) inset
    }

    /* Title with depth */
    .title{
      font-size: clamp(28px, 5vw, 56px);
      line-height:1.18;
      margin:6px 0 8px;
      padding-bottom:8px;
      font-weight:900;
      letter-spacing:.4px;
      color:#fff;
      text-shadow:
        0 1px 0 #f3e1cf,
        0 2px 0 #e6c49b,
        0 3px 0 #c88852,
        0 4px 10px rgba(0,0,0,.35);
    }
    .subtitle{opacity:.92;font-size:clamp(14px,2.2vw,18px);line-height:1.5}
    .btn-row{display:flex;flex-wrap:wrap;gap:10px;margin-top:18px}
    button{
      background:linear-gradient(180deg,#ffa24d,#ff7a00);
      color:#120900;border:0;border-radius:12px;padding:12px 16px;
      font-weight:800;letter-spacing:.3px;cursor:pointer;box-shadow:0 6px 24px rgba(255,122,0,.35)
    }
    .list{margin:10px 0 0 0;padding-left:18px;font-size:14px;opacity:.94}
    .badge{margin-top:6px;display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;background:#16181f;border:1px solid rgba(255,122,0,.28);font-size:12px}
    .brand{display:flex;align-items:center;gap:10px;margin-bottom:8px}
    .logo{width:54px;height:54px;border-radius:50%;position:relative;display:inline-block;background:radial-gradient(circle at 30% 30%,#ffd69f 0%, #ffb157 28%, #ff8a1c 58%, #ff7a00 75%, #e86d00 100%);box-shadow:0 6px 28px rgba(255,122,0,.45), inset 0 0 12px rgba(255,255,255,.2)}
    .logo:before{content:"";position:absolute;right:-6px;top:-8px;width:22px;height:14px;border-radius:20px 20px 2px 20px/18px 18px 2px 18px;background:linear-gradient(180deg,#5ed06b,#2e9a3b);transform:rotate(28deg);box-shadow:0 2px 6px rgba(0,0,0,.2)}
    .logo:after{content:"";position:absolute;left:8px;top:26px;width:38px;height:10px;border-radius:6px;background:linear-gradient(90deg,#fff 0 22%, #ff7a00 22% 78%, #fff 78% 100%)}
    #centerText{
      position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
      padding:8px 14px;border-radius:12px;background:rgba(0,0,0,.55);
      color:#ffd8b3;font-weight:800;letter-spacing:.5px;z-index:2;display:none
    }
    .hidden{display:none !important}

    /* Start UI "Sign" hero */
    .sign-hero{
      position:relative;margin:-8px -8px 16px -8px;padding:24px 18px;border-radius:14px;
      background:
        radial-gradient(800px 420px at 15% 10%, rgba(255,205,120,.25), transparent 60%),
        linear-gradient(180deg,#ffb85a 0%, #ff9320 40%, #ff7a00 100%);
      overflow:hidden
    }
    .sign-word{
      font-family: "Georgia","Times New Roman",serif;
      font-style: italic;
      font-weight: 800;
      letter-spacing:.5px;
      font-size: clamp(38px,8vw,82px);
      line-height: .9;
      color:#fff;
      text-shadow: 0 8px 24px rgba(0,0,0,.25);
      position:relative;display:inline-block
    }
    .sign-word .dot{
      position:absolute;left:calc(0.88ch);top:-0.26em;width:.35em;height:.35em;border-radius:50%;
      background:radial-gradient(circle at 30% 30%,#ffd69f 0,#ffb157 30%,#ff8a1c 60%,#ff7a00 100%);
      box-shadow:0 3px 10px rgba(0,0,0,.25)
    }
    .sign-word .leaf{
      position:absolute;left:calc(0.88ch + .28em);top:-0.44em;width:.45em;height:.28em;border-radius:50%;
      background:linear-gradient(180deg,#64e27b,#2aa446);
      transform:rotate(18deg);
      box-shadow:0 2px 6px rgba(0,0,0,.2)
    }
    .sign-star{
      position:absolute;right:14px;top:10px;width:18px;height:18px;background:conic-gradient(from 0deg,#ffd67a, #fff 40%, #ffd67a);
      clip-path:polygon(50% 0,60% 38%,100% 50%,60% 62%,50% 100%,40% 62%,0 50%,40% 38%);
      filter:drop-shadow(0 3px 8px rgba(0,0,0,.25))
    }
    .credit{
      margin-top:8px;
      text-align:center;
      font-weight:900;
      letter-spacing:.6px;
      font-size:clamp(14px,2.2vw,16px);
      color:#fff;
      text-shadow:
        0 0 6px rgba(255,122,0,.7),
        0 0 18px rgba(255,170,60,.7),
        0 0 36px rgba(255,122,0,.5);
    }

    /* Power-up blurb styling on start UI */
    .pu-list{margin:14px 0 0 0;display:grid;gap:10px}
    .pu-row{
      display:flex;align-items:center;gap:12px;
      background:linear-gradient(180deg,#14151b,#0f1015);
      border:1px solid rgba(255,122,0,.22);
      border-radius:12px;
      padding:10px 12px;
      box-shadow:0 6px 22px rgba(255,122,0,.08) inset;
    }
    .pu-icon{
      width:34px;height:34px;border-radius:10px;
      display:inline-flex;align-items:center;justify-content:center;
      font-size:20px;font-weight:900;user-select:none;
      box-shadow:0 4px 14px rgba(0,0,0,.35);
    }
    .pu-ice{background:linear-gradient(180deg,#c7ecff,#7ec6ff); color:#0a2740;}
    .pu-ghost{background:linear-gradient(180deg,#ffffff,#dfeaff); color:#1a3f6b;}
    .pu-frenzy{background:linear-gradient(180deg,#ff7777,#ff3a3a); color:#250202;}
    .pu-text{flex:1; font-size:14px; opacity:.95}
    .pu-em{font-weight:800;color:#ffd9b0}

    /* D-Pad (position and sizing controlled by JS via CSS vars) */
    #dpad{
      position:absolute;z-index:4;
      /* Centering and top are set in JS */
      background:linear-gradient(180deg, rgba(6,7,10,0.85) 0%, rgba(9,10,15,0.85) 100%);
      border:1px solid rgba(255,122,0,.15);
      border-radius:16px;
      box-shadow:0 -8px 30px rgba(0,0,0,.5);
      padding:10px;
      backdrop-filter: blur(6px);
    }
    .pad{
      display:grid;
      grid-template-columns:1fr 1fr 1fr;
      grid-template-rows:1fr 1fr 1fr;
      gap: var(--gap,12px);
      width: var(--pad-w,720px);
      height: var(--pad-h,720px);
      touch-action:none;
    }
    .dpad-btn{
      width: var(--btn,140px);
      height: var(--btn,140px);
      background:linear-gradient(180deg,#171a20,#0f1217);
      border:1px solid rgba(255,122,0,.35);
      box-shadow:0 10px 28px rgba(255,122,0,.18), 0 2px 0 rgba(255,255,255,.05) inset;
      color:#ffd9b0;font-size: var(--fs,38px);font-weight:900;border-radius:14px;
      display:flex;align-items:center;justify-content:center;
      user-select:none;cursor:pointer
    }
    .dpad-btn:active{transform:scale(0.98)}
    .dpad-empty{pointer-events:none;opacity:0}
  </style>
</head>
<body>
  <div id="game-wrap">
    <canvas id="game" aria-label="Sign Orang Dynasty Arcade Maze Game" role="img"></canvas>

    <div id="hud">
      <div class="pill" id="hudLevel">Level 1 / 50</div>
      <div class="hud-right">
        <div class="pill" id="hudDots">Dots: 0</div>
        <div class="pill" id="hudStatus">Ready</div>
      </div>
    </div>

    <div id="centerText"></div>

    <!-- Start overlay -->
    <div id="startOverlay" class="overlay">
      <div class="card">
        <div class="sign-hero">
          <div class="sign-word">Sign
            <span class="dot"></span>
            <span class="leaf"></span>
          </div>
          <div class="sign-star"></div>
        </div>

        <div class="brand">
          <span class="logo"></span>
          <div>
            <div class="badge">Orange Theme ‚Ä¢ Tight Maze ‚Ä¢ 50 Levels</div>
          </div>
        </div>
        <h1 class="title">Sign Orang Dynasty Arcade Maze Game</h1>
        <p class="subtitle">
          A fast-paced, retro-style maze chase where you collect points, dodge enemies, and clear levels in an endless arcade challenge.
        </p>
        <p class="subtitle" style="opacity:.92">
          Controls: Arrow Keys / WASD (PC) ‚Ä¢ On-screen D-Pad (Mobile). Movement is continuous until a wall blocks you.<br>
          Power-ups: 3 per level, spread apart.
        </p>

        <!-- Icon-led power-up list -->
        <div class="pu-list">
          <div class="pu-row">
            <span class="pu-icon pu-ice">‚ùÑÔ∏è</span>
            <div class="pu-text"><span class="pu-em">11s</span> ‚Äî Enemies freeze; you pass through. Thicker icy aura and snowy sparkles.</div>
          </div>
          <div class="pu-row">
            <span class="pu-icon pu-ghost">üëª</span>
            <div class="pu-text"><span class="pu-em">12s</span> ‚Äî Opaque ghost cloak covers you completely; timing pulse; spooky motes swirl.</div>
          </div>
          <div class="pu-row">
            <span class="pu-icon pu-frenzy">‚ö°Ô∏è</span>
            <div class="pu-text"><span class="pu-em">10s</span> ‚Äî Chomp enemies; they respawn after 5s. Thick red aura with quick lightning.</div>
          </div>
        </div>

        <div class="btn-row">
          <button id="startBtn">Play</button>
        </div>
        <div class="credit">Created by Agrigorn ‚Ä¢ A retro-inspired maze chase game.</div>
      </div>
    </div>

    <!-- Game over overlay -->
    <div id="gameOverOverlay" class="overlay hidden">
      <div class="card">
        <h2 class="title">Game Over</h2>
        <p class="subtitle" id="goText">Caught by an enemy! Try again, swap the maze, or return to the main menu.</p>
        <div class="btn-row">
          <button id="retryBtn">Restart Level</button>
          <button class="secondary" id="changeMazeBtn">Change Maze</button>
          <button id="menuBtn">Main Menu</button>
        </div>
      </div>
    </div>

    <!-- End overlay -->
    <div id="endOverlay" class="overlay hidden">
      <div class="card">
        <h2 class="title">You cleared all 50 levels! üçäüëë</h2>
        <p class="subtitle">The Sign Orang Dynasty salutes your maze mastery.</p>
        <div class="btn-row">
          <button id="restartBtn">Play Again</button>
        </div>
      </div>
    </div>

    <!-- D-Pad controls (positioned via JS just beneath the maze) -->
    <div id="dpad" aria-label="Directional controls">
      <div class="pad">
        <div class="dpad-empty"></div>
        <div class="dpad-btn" data-dir="up" aria-label="Up">‚ñ≤</div>
        <div class="dpad-empty"></div>

        <div class="dpad-btn" data-dir="left" aria-label="Left">‚óÄ</div>
        <div class="dpad-empty"></div>
        <div class="dpad-btn" data-dir="right" aria-label="Right">‚ñ∂</div>

        <div class="dpad-empty"></div>
        <div class="dpad-btn" data-dir="down" aria-label="Down">‚ñº</div>
        <div class="dpad-empty"></div>
      </div>
    </div>

  </div>

  <script>
  (() => {
    // Maze settings
    const COLS = 22;
    const ROWS = 25;
    const MAX_LEVEL = 50;
    // Slower speeds for finer control
    const PLAYER_SPEED_TPS = 5.2;   // was 7.0
    const ENEMY_SPEED_TPS  = 4.8;   // was 6.2
    const ENEMY_IDLE_SPEED = 1.6;   // was 2.2
    const TILE_ASPECT_MARGIN = 0.96;

    // DOM
    const wrap   = document.getElementById('game-wrap');
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const hudLevel  = document.getElementById('hudLevel');
    const hudDots   = document.getElementById('hudDots');
    const hudStatus = document.getElementById('hudStatus');
    const centerText= document.getElementById('centerText');
    const dpad = document.getElementById('dpad');
    const pad = dpad.querySelector('.pad');

    const startOverlay = document.getElementById('startOverlay');
    const endOverlay   = document.getElementById('endOverlay');
    const gameOverOverlay = document.getElementById('gameOverOverlay');

    document.getElementById('startBtn').onclick = () => { startOverlay.classList.add('hidden'); startGame(); };
    document.getElementById('retryBtn').onclick = () => { gameOverOverlay.classList.add('hidden'); restartSameLevel(); };
    document.getElementById('changeMazeBtn').onclick = () => { gameOverOverlay.classList.add('hidden'); changeMazeSameLevel(); };
    document.getElementById('menuBtn').onclick = () => { gameOverOverlay.classList.add('hidden'); showMenu(); };
    document.getElementById('restartBtn').onclick = () => { endOverlay.classList.add('hidden'); startGame(true); };

    function showMenu(){
      running=false;
      drawMenuBackdrop();
      startOverlay.classList.remove('hidden');
    }

    // Compute D-Pad responsive sizing
    function computeDpadSize(){
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      // Button size aims to be big on both mobile and desktop (including mobile emulation)
      const btn = Math.floor(Math.max(96, Math.min(160, Math.min(vw, vh)*0.18)));
      const gap = Math.max(12, Math.floor(btn*0.12));     // spacing between buttons
      const fs  = Math.floor(btn*0.28);                   // icon text size
      const padW = btn*3 + gap*2;
      const padH = btn*3 + gap*2;
      return {btn, gap, fs, padW, padH};
    }

    // Responsive canvas and D-Pad placement
    let TILE = 24;
    function resizeCanvas(){
      // Size D-Pad first to reserve room for it
      const sz = computeDpadSize();
      // Reserve space below maze so D-Pad fits right under it
      const reserveH = sz.padH + 16; // 16px breathing room
      const w = window.innerWidth;
      const hAvail = Math.max(240, window.innerHeight - reserveH);
      const tileW = Math.floor((w * TILE_ASPECT_MARGIN) / COLS);
      const tileH = Math.floor((hAvail * TILE_ASPECT_MARGIN) / ROWS);
      TILE = Math.max(10, Math.min(tileW, tileH));
      canvas.width = COLS * TILE;
      canvas.height= ROWS * TILE;
      // Center canvas at top area (above D-Pad)
      const top = Math.max(0, Math.floor((hAvail - canvas.height)/2));
      const left = Math.floor((w - canvas.width)/2);
      canvas.style.top  = `${top}px`;
      canvas.style.left = `${left}px`;

      // Apply D-Pad size via CSS vars
      dpad.style.setProperty('--btn', `${sz.btn}px`);
      dpad.style.setProperty('--gap', `${sz.gap}px`);
      dpad.style.setProperty('--pad-w', `${sz.padW}px`);
      dpad.style.setProperty('--pad-h', `${sz.padH}px`);
      dpad.style.setProperty('--fs', `${sz.fs}px`);

      // Position D-Pad directly below maze bottom boundary wall
      const margin = Math.max(6, Math.floor(TILE*0.25));
      const dpadTop = top + canvas.height + margin;
      const dpadLeft = Math.max(8, Math.floor((w - sz.padW)/2));
      dpad.style.top = `${dpadTop}px`;
      dpad.style.left= `${dpadLeft}px`;
    }
    window.addEventListener('resize', resizeCanvas, {passive:true});
    resizeCanvas();

    // Utilities
    const DIRS = { up:{x:0,y:-1}, down:{x:0,y:1}, left:{x:-1,y:0}, right:{x:1,y:0} };
    const dirList = [DIRS.up, DIRS.left, DIRS.down, DIRS.right];
    function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
    function makeRand(seed){ let s = seed>>>0; return () => (s=(s*1664525+1013904223)>>>0, s/4294967296); }
    function lerp(a,b,t){return a+(b-a)*t;}

    // Animation timers and power-ups
    let animT = 0;
    let lastCommandMs = performance.now();
    let freezeTimer = 0;     // 11s
    let invulnTimer = 0;     // 12s
    let frenzyTimer = 0;     // 10s

    // Particles
    let freezeFlakes = []; // freeze snow around player
    let ghostMotes = [];   // spooky motes during ghost

    // World/grid generation
    // grid: 0 wall, 1 pellet, 2 empty path, 3 ghost area, 4 freeze PU, 5 invuln PU, 6 frenzy PU
    function generateMaze(seed){
      const rnd = makeRand(seed*1337+9001);
      const grid = Array.from({length:ROWS},()=>Array(COLS).fill(0));
      const W = Math.floor(COLS/2), H = ROWS;

      // carve odd cells on left half
      for(let y=1;y<H-1;y+=2) for(let x=1;x<W-1;x+=2) grid[y][x]=1;

      // DFS
      const sx = 1 + 2*Math.floor(rnd()*((W-2)/2));
      const sy = 1 + 2*Math.floor(rnd()*((H-2)/2));
      const st=[{x:sx,y:sy}], vis=new Set([sy+','+sx]);
      function oddNeighbors(x,y){
        const a=[];
        if(y-2>0) a.push({x,y:y-2,wx:x,wy:y-1});
        if(y+2<H-1) a.push({x,y:y+2,wx:x,wy:y+1});
        if(x-2>0) a.push({x:x-2,y,wx:x-1,wy:y});
        if(x+2<W-1) a.push({x:x+2,y,wx:x+1,wy:y});
        return a.sort(()=>rnd()-.5);
      }
      while(st.length){
        const cur = st.at(-1);
        const nbs = oddNeighbors(cur.x,cur.y).filter(n=>!vis.has(n.y+','+n.x));
        if(nbs.length){
          const n=nbs[0]; grid[n.wy][n.wx]=1; vis.add(n.y+','+n.x); st.push({x:n.x,y:n.y});
        }else st.pop();
      }

      // Add more loops to improve branching
      const loopAdds = Math.floor((W*H)/14);
      for(let i=0;i<loopAdds;i++){
        const x=2+Math.floor(rnd()*(W-4)), y=2+Math.floor(rnd()*(H-4));
        if(grid[y][x]===0 && ((grid[y][x-1]&&grid[y][x+1])||(grid[y-1][x]&&grid[y+1][x]))) grid[y][x]=1;
      }

      // Mirror symmetry
      for(let y=0;y<ROWS;y++) for(let x=0;x<W;x++) grid[y][COLS-1-x]=grid[y][x];

      // Borders
      for(let x=0;x<COLS;x++){ grid[0][x]=0; grid[ROWS-1][x]=0; }
      for(let y=0;y<ROWS;y++){ grid[y][0]=0; grid[y][COLS-1]=0; }

      // Center tunnel row
      const tunnelRow = Math.floor(ROWS/2);
      for(let x=0;x<COLS;x++) grid[tunnelRow][x]=1;
      grid[tunnelRow][0]=1; grid[tunnelRow][COLS-1]=1;

      // Ghost house
      const ghW = Math.max(6, Math.floor(COLS/3)), ghH=5;
      const cx = Math.floor(COLS/2), cy=Math.floor(ROWS/2)-1;
      const halfW=Math.floor(ghW/2), halfH=Math.floor(ghH/2);
      for(let y=cy-halfH;y<=cy+halfH;y++) for(let x=cx-halfW;x<=cx+halfW;x++) grid[y][x]=3;
      if(grid[cy+halfH+1]) grid[cy+halfH+1][cx]=1;
      grid[cy+halfH][cx]=3;

      // Clear pellets near house
      for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++){
        if(grid[y][x]===1){
          const d=Math.abs(x-cx)+Math.abs(y-cy);
          if(d<=2) grid[y][x]=2;
        }
      }

      // Player start area
      const ps={x:cx, y:ROWS-4};
      for(let yy=ps.y-1; yy<=ps.y+1; yy++){
        for(let xx=ps.x-1; xx<=ps.x+1; xx++){
          if(xx>0&&xx<COLS-1&&yy>0&&yy<ROWS-1) grid[yy][xx]=(yy===ps.y && xx===ps.x)?2:1;
        }
      }

      // Count pellets
      let dots=0; for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++) if(grid[y][x]===1) dots++;

      return {grid, dots, playerStart:ps, ghostStarts:[
        {x:cx-2,y:cy-1},{x:cx+2,y:cy-1},{x:cx-2,y:cy+1},{x:cx+2,y:cy+1}
      ], seed};
    }

    // Place power-ups (4=freeze, 5=ghost, 6=frenzy), far apart
    function placePowerups(world){
      const pellets=[], extras=[];
      for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++){
        if(world.grid[y][x]===1) pellets.push({x,y});
        else if(world.grid[y][x]===2) extras.push({x,y});
      }
      let candidates = pellets.slice();
      if(candidates.length<3) candidates = candidates.concat(extras);
      if(candidates.length<3) return;

      const dist=(a,b)=>Math.abs(a.x-b.x)+Math.abs(a.y-b.y);
      const first = candidates[Math.floor(Math.random()*candidates.length)];
      let second=first, best=-1;
      for(const p of candidates){ const d=dist(p,first); if(d>best){best=d; second=p;} }
      let third=first, bestMin=-1;
      for(const p of candidates){ const d=Math.min(dist(p,first),dist(p,second)); if(d>bestMin){bestMin=d; third=p;} }

      const spots=[first,second,third];
      const types=[4,5,6].sort(()=>Math.random()-.5);
      for(let i=0;i<3;i++){
        const {x,y}=spots[i];
        if(world.grid[y][x]===1) { world.dots--; }
        world.grid[y][x]=types[i];
      }
    }

    function buildOpenTiles(grid){
      const arr=[];
      for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++){
        if(grid[y][x]!==0) arr.push({x,y});
      }
      return arr;
    }

    // Game State
    let level=1, currentSeed=1, world=null, player=null, enemies=[], dotsLeft=0, lastTime=0, running=false;
    let desiredDir = {x:0,y:0};
    let hasMoved=false;
    let openTiles=[];

    function startGame(resetAll=false){
      if(resetAll){ level=1; currentSeed=1; }
      loadLevel(level, level);
      running = true; lastTime = performance.now(); requestAnimationFrame(loop);
    }
    function restartSameLevel(){
      loadLevel(level, currentSeed);
      running = true; lastTime = performance.now(); requestAnimationFrame(loop);
    }
    function changeMazeSameLevel(){
      let s=currentSeed;
      do{ s = 1 + Math.floor(Math.random()*MAX_LEVEL); } while(s===currentSeed);
      loadLevel(level, s);
      running = true; lastTime = performance.now(); requestAnimationFrame(loop);
    }

    function loadLevel(n, seedForMaze){
      currentSeed = seedForMaze;
      world = generateMaze(seedForMaze);
      placePowerups(world);
      dotsLeft = world.dots;
      openTiles = buildOpenTiles(world.grid);

      player = { x:world.playerStart.x+0.5, y:world.playerStart.y+0.5, dir:{x:0,y:0}, speed:PLAYER_SPEED_TPS, radius:0.44 };
      desiredDir = {x:0,y:0};
      hasMoved=false;
      freezeTimer=0; invulnTimer=0; frenzyTimer=0;
      freezeFlakes.length = 0;
      ghostMotes.length = 0;

      const starts = world.ghostStarts;
      enemies = [0,1,2,3].map(i => ({
        x: starts[i].x + 0.5,
        y: starts[i].y + 0.5,
        dir: DIRS.left,
        auraHue: [200, 300, 120, 40][i],
        speedActive: ENEMY_SPEED_TPS,
        speed: 0,
        radius: 0.46,
        jitter: (i+1)*0.17,
        crunchOffset: Math.random()*Math.PI*2,
        particles: [],
        pulse: 0,
        state:'alive',
        respawn:0
      }));

      hudLevel.textContent = `Level ${n} / ${MAX_LEVEL}`;
      hudDots.textContent  = `Dots: ${dotsLeft}`;
      hudStatus.textContent= 'Ready';
      centerText.style.display = 'none';
      gameOverOverlay.classList.add('hidden');

      // Ensure layout is correct after (re)load
      resizeCanvas();
    }

    // Keyboard input
    window.addEventListener('keydown', (e)=>{
      const k = e.key.toLowerCase();
      if(['arrowup','w'].includes(k)) desiredDir = DIRS.up;
      else if(['arrowdown','s'].includes(k)) desiredDir = DIRS.down;
      else if(['arrowleft','a'].includes(k)) desiredDir = DIRS.left;
      else if(['arrowright','d'].includes(k)) desiredDir = DIRS.right;
      lastCommandMs = performance.now();
    });

    // On-screen D-Pad
    function setDirFromButton(dir){
      if(dir==='up') desiredDir = DIRS.up;
      if(dir==='down') desiredDir = DIRS.down;
      if(dir==='left') desiredDir = DIRS.left;
      if(dir==='right') desiredDir = DIRS.right;
      lastCommandMs = performance.now();
    }
    document.querySelectorAll('.dpad-btn').forEach(btn=>{
      const dir = btn.getAttribute('data-dir');
      const handler = (e)=>{ e.preventDefault(); setDirFromButton(dir); };
      btn.addEventListener('pointerdown', handler);
      btn.addEventListener('click', handler);
      btn.addEventListener('touchstart', handler, {passive:false});
    });

    // Grid helpers
    function isWall(tx,ty){
      if(ty<0||ty>=ROWS) return true;
      if(tx<0 || tx>=COLS) return !isTunnelRow(ty, world.grid);
      return world.grid[ty][tx]===0;
    }
    function isTunnelRow(ty, grid){
      if(ty<0||ty>=ROWS) return false;
      return (grid[ty][0]!==0) && (grid[ty][COLS-1]!==0);
    }
    function isPath(tx,ty){ return world.grid[ty] && (world.grid[ty][tx]!==0); }
    function isHouse(tx,ty){ return world.grid[ty] && world.grid[ty][tx]===3; }
    function canMove(cx,cy,dir){
      if(dir.x!==0){
        const nx = dir.x>0? Math.floor(cx+1) : Math.floor(cx-1);
        return !isWall(nx, cy);
      }else if(dir.y!==0){
        const ny = dir.y>0? Math.floor(cy+1) : Math.floor(cy-1);
        return !isWall(cx, ny);
      }
      return true;
    }

    function stepEntity(ent, dt){
      const cx = Math.floor(ent.x), cy = Math.floor(ent.y);
      const centerX = cx + 0.5, centerY = cy + 0.5;
      const atCenter = Math.abs(ent.x-centerX)<0.05 && Math.abs(ent.y-centerY)<0.05;

      if(ent === player){
        if(atCenter){
          if(canMove(cx,cy,desiredDir)){
            if((ent.dir.x===0 && ent.dir.y===0) && (desiredDir.x||desiredDir.y)) hasMoved=true;
            ent.dir = desiredDir;
          }else if(!canMove(cx,cy,ent.dir)){
            ent.dir = {x:0,y:0};
          }
        }
      }

      ent.x += ent.dir.x * ent.speed * dt;
      ent.y += ent.dir.y * ent.speed * dt;

      const row = Math.floor(ent.y);
      if(isTunnelRow(row, world.grid)){
        if(ent.x < -0.5) ent.x = COLS - 0.5;
        if(ent.x > COLS + 0.5) ent.x = 0.5;
      }

      const tx = Math.floor(ent.x), ty=Math.floor(ent.y);
      if(ent.dir.x!==0){
        const nextTx = ent.dir.x>0? Math.floor(ent.x+ent.radius) : Math.floor(ent.x-ent.radius);
        if(isWall(nextTx, ty)){ ent.x = centerX; if(ent===player && canMove(cx,cy,desiredDir)) ent.dir=desiredDir; else ent.dir={x:0,y:0}; }
      }
      if(ent.dir.y!==0){
        const nextTy = ent.dir.y>0? Math.floor(ent.y+ent.radius) : Math.floor(ent.y-ent.radius);
        if(isWall(tx, nextTy)){ ent.y = centerY; if(ent===player && canMove(cx,cy,desiredDir)) ent.dir=desiredDir; else ent.dir={x:0,y:0}; }
      }

      if(ent.dir.x===0) ent.x = clamp(ent.x, centerX-0.001, centerX+0.001);
      if(ent.dir.y===0) ent.y = clamp(ent.y, centerY-0.001, centerY+0.001);
    }

    function stepEnemy(g, dt){
      if(g.state==='eaten'){
        g.respawn -= dt;
        if(g.respawn<=0){
          for(let tries=0; tries<400; tries++){
            const pick = openTiles[Math.floor(Math.random()*openTiles.length)];
            if(world.grid[pick.y][pick.x]!==0){
              g.x = pick.x + 0.5;
              g.y = pick.y + 0.5;
              g.dir = [DIRS.left,DIRS.right,DIRS.up,DIRS.down][Math.floor(Math.random()*4)];
              g.state='alive';
              break;
            }
          }
        }
        return;
      }

      const frozen = freezeTimer>0;
      const idle = !hasMoved;

      g.speed = idle ? ENEMY_IDLE_SPEED : (frozen ? 0 : g.speedActive);

      const cx = Math.floor(g.x), cy = Math.floor(g.y);
      const centerX = cx+0.5, centerY=cy+0.5;
      const atCenter = Math.abs(g.x-centerX)<0.05 && Math.abs(g.y-centerY)<0.05;

      if(atCenter && (!frozen)){
        const options = [];
        for(const d of dirList){
          if(g.dir && g.dir.x===-d.x && g.dir.y===-d.y) continue;
          if(!canMove(cx,cy,d)) continue;
          if(idle){
            const nx = cx + d.x, ny = cy + d.y;
            if(!isHouse(nx,ny)) continue;
          }
          options.push(d);
        }
        if(options.length===0){
          const rev={x:-g.dir.x,y:-g.dir.y};
          if(!idle || (idle && isHouse(cx - g.dir.x, cy - g.dir.y))) g.dir=rev;
        }else{
          if(idle){
            g.dir = options[Math.floor(Math.random()*options.length)];
          }else{
            const t=predictPlayerTarget();
            options.sort((a,b)=>{
              const da=Math.abs((cx+a.x)-t.x)+Math.abs((cy+a.y)-t.y);
              const db=Math.abs((cx+b.x)-t.x)+Math.abs((cy+b.y)-t.y);
              return da-db;
            });
            const r=Math.random()+g.jitter*0.03;
            g.dir = r<0.82? options[0] : options[Math.floor(Math.random()*options.length)];
          }
        }
      }

      g.x += g.dir.x * g.speed * dt;
      g.y += g.dir.y * g.speed * dt;

      const row = Math.floor(g.y);
      if(isTunnelRow(row, world.grid)){
        if(g.x < -0.5) g.x = COLS - 0.5;
        if(g.x > COLS + 0.5) g.x = 0.5;
      }

      const tx = Math.floor(g.x), ty=Math.floor(g.y);

      if(g.dir.x!==0){
        const n = g.dir.x>0? Math.floor(g.x+g.radius) : Math.floor(g.x-g.radius);
        const leavingHouse = idle && world.grid[ty] && world.grid[ty][n]!==3;
        if(isWall(n, ty) || leavingHouse){ g.x = Math.floor(g.x)+0.5; g.dir={x:0,y:0}; }
      }
      if(g.dir.y!==0){
        const n = g.dir.y>0? Math.floor(g.y+g.radius) : Math.floor(g.y-g.radius);
        const leavingHouse = idle && world.grid[n] && world.grid[n][tx]!==3;
        if(isWall(tx, n) || leavingHouse){ g.y = Math.floor(g.y)+0.5; g.dir={x:0,y:0}; }
      }

      // Aura / pulse
      if(hasMoved && !frozen && Math.random()<0.06){ g.pulse = 1; }
      if(hasMoved && !frozen && Math.random()<0.1 && g.particles.length<18){
        const a = Math.random()*Math.PI*2;
        const sp = 1.2 + Math.random()*0.7;
        g.particles.push({x:g.x+Math.cos(a)*0.3, y:g.y+Math.sin(a)*0.3, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, age:0, life:0.28});
      }
      for(let i=g.particles.length-1;i>=0;i--){
        const p=g.particles[i];
        p.age+=dt; if(p.age>p.life){ g.particles.splice(i,1); continue; }
        p.x+=p.vx*dt; p.y+=p.vy*dt;
      }
    }

    function predictPlayerTarget(){
      const p = player, ahead=3;
      let tx=Math.floor(p.x + p.dir.x*ahead), ty=Math.floor(p.y + p.dir.y*ahead);
      tx=clamp(tx,0,COLS-1); ty=clamp(ty,0,ROWS-1);
      if(!isPath(tx,ty)){ tx=Math.floor(p.x); ty=Math.floor(p.y); }
      return {x:tx,y:ty};
    }

    // Eat pellets and power-ups
    function tryEatPellet(){
      const cx = Math.floor(player.x), cy = Math.floor(player.y);
      const v = world.grid[cy][cx];
      if(v===1){
        world.grid[cy][cx]=2; dotsLeft--; hudDots.textContent=`Dots: ${dotsLeft}`;
        if(dotsLeft<=0){ hudStatus.textContent='Level Clear!'; nextLevel(); }
      }else if(v===4 || v===5 || v===6){
        world.grid[cy][cx]=2;
        if(v===4){ freezeTimer = 11; hudStatus.textContent='Freeze! 11s'; }
        else if(v===5){
          invulnTimer = 12; hudStatus.textContent='Ghost! 12s';
        }else { frenzyTimer = 10; hudStatus.textContent='Frenzy! 10s'; }
      }
    }

    function nextLevel(){
      level++;
      if(level>MAX_LEVEL){
        running=false;
        endOverlay.classList.remove('hidden');
        return;
      }
      centerText.textContent = `Level ${level}`;
      centerText.style.display='block';
      setTimeout(()=>{ centerText.style.display='none'; loadLevel(level, level); }, 500);
    }

    // Collision rules
    function checkDeath(){
      for(const g of enemies){
        if(g.state!=='alive') continue;
        const dx = (g.x - player.x)*TILE;
        const dy = (g.y - player.y)*TILE;
        if(Math.hypot(dx,dy) < TILE*0.6){
          if(frenzyTimer>0){
            // eat enemy, respawn later
            g.state='eaten'; g.respawn=5;
            for(let i=0;i<12;i++){
              const a=Math.random()*Math.PI*2, sp=2+Math.random()*2;
              g.particles.push({x:g.x,y:g.y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,age:0,life:0.3});
            }
            continue;
          }
          if(invulnTimer>0 || freezeTimer>0) continue; // pass-through
          running=false;
          hudStatus.textContent = 'Game Over';
          gameOverOverlay.classList.remove('hidden');
          return;
        }
      }
    }

    // Rendering
    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      drawSignWatermark();
      drawMaze3D();
      drawPellets();
      drawPowerups();
      drawEnemies();
      drawPlayer();
    }

    // Watermark: subtle edge-only strip sweeping S -> N every 7s
    function drawSignWatermark(){
      ctx.save();
      const text = 'Sign';
      const size = Math.floor(Math.min(canvas.width, canvas.height)*0.5);
      ctx.font = `italic ${size}px Georgia, 'Times New Roman', serif`;
      const metrics = ctx.measureText(text);
      const x = (canvas.width - metrics.width)/2;
      const y = canvas.height*0.35 + size*0.4;

      // base soft fill
      ctx.globalAlpha = 0.10; ctx.fillStyle='#ffd6a8'; ctx.fillText(text, x+2, y+2);
      ctx.globalAlpha = 0.18; ctx.fillStyle='#ffffff'; ctx.fillText(text, x, y);

      // sweeping edge strip (South -> North)
      const period = 7.0;
      const p = (animT / period) % 1;
      const bandCenterY = canvas.height * (1 - p);
      const bandHalf = Math.max(6, size*0.04);

      const g = ctx.createLinearGradient(0,0,0,canvas.height);
      const c0 = Math.max(0, (bandCenterY - bandHalf)/canvas.height);
      const c1 = Math.max(0, (bandCenterY - bandHalf*0.4)/canvas.height);
      const c2 = Math.min(1, (bandCenterY + bandHalf*0.4)/canvas.height);
      const c3 = Math.min(1, (bandCenterY + bandHalf)/canvas.height);
      g.addColorStop(0, 'rgba(255,255,255,0)');
      g.addColorStop(c0, 'rgba(255,255,255,0)');
      g.addColorStop(c1, 'rgba(255,255,255,0.55)');
      g.addColorStop((c1+c2)/2, 'rgba(255,255,255,0.9)');
      g.addColorStop(c2, 'rgba(255,255,255,0.55)');
      g.addColorStop(c3, 'rgba(255,255,255,0)');
      g.addColorStop(1, 'rgba(255,255,255,0)');

      ctx.globalAlpha = 0.7;
      ctx.strokeStyle = g;
      ctx.lineWidth = Math.max(2, size * 0.045);
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      ctx.strokeText(text, x, y);

      ctx.restore();
    }

    // 3D-styled walls with texture and shadows
    function drawMaze3D(){
      for(let y=0;y<ROWS;y++){
        for(let x=0;x<COLS;x++){
          if(world.grid[y][x]===0){
            const px=x*TILE, py=y*TILE, w=TILE, h=TILE;
            const g=ctx.createLinearGradient(px,py,px,py+h);
            g.addColorStop(0,'#ffb56b');
            g.addColorStop(0.45,'#ff8e1f');
            g.addColorStop(1,'#d96800');
            ctx.fillStyle=g;
            roundRect(px+0.5,py+0.5,w-1,h-1, Math.floor(TILE*0.22));

            ctx.fillStyle='rgba(255,220,170,0.35)';
            ctx.fillRect(px+2,py+2,w-4,Math.max(2,Math.floor(h*0.12)));

            ctx.fillStyle='rgba(0,0,0,0.25)';
            ctx.fillRect(px+w-3,py+3,2,h-6);
            ctx.fillRect(px+3,py+h-3,w-6,2);

            ctx.fillStyle='rgba(255,255,255,0.04)';
            for(let i=0;i<2;i++){
              const sx=px+4+Math.random()*(w-8), sy=py+4+Math.random()*(h-8);
              ctx.fillRect(sx,sy,1,1);
            }
          }
        }
      }
    }
    function roundRect(x,y,w,h,r){
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
      ctx.fill();
    }

    function drawPellets(){
      ctx.save();
      for(let y=0;y<ROWS;y++){
        for(let x=0;x<COLS;x++){
          if(world.grid[y][x]===1){
            const px = (x+0.5)*TILE, py=(y+0.5)*TILE;
            ctx.fillStyle='#ffd9b0';
            ctx.beginPath();
            ctx.arc(px,py,Math.max(3,Math.floor(TILE*0.12)),0,Math.PI*2);
            ctx.fill();
          }
        }
      }
      ctx.restore();
    }

    function drawPowerups(){
      for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++){
        const v=world.grid[y][x];
        if(v===4 || v===5 || v===6){
          const cx=(x+0.5)*TILE, cy=(y+0.5)*TILE;

          // light bob and soft glow
          const bob = Math.sin(animT*2.2 + (x+y)) * Math.min(4, TILE*0.12);
          ctx.save();
          ctx.translate(0, -bob);
          ctx.shadowColor = v===6 ? 'rgba(255,70,70,0.55)' : (v===5 ? 'rgba(150,190,255,0.45)' : 'rgba(160,220,255,0.55)');
          ctx.shadowBlur = Math.max(2, TILE*0.25);

          if(v===4){
            // Freeze: snowflake
            ctx.translate(cx,cy);
            const r=TILE*0.30;
            ctx.strokeStyle='rgba(160,220,255,0.98)';
            ctx.lineWidth=Math.max(2,Math.floor(TILE*0.07));
            for(let i=0;i<6;i++){
              ctx.rotate(Math.PI/3);
              ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(0,-r); ctx.stroke();
              ctx.beginPath(); ctx.moveTo(0,-r*0.6); ctx.lineTo(r*0.12,-r*0.78); ctx.moveTo(0,-r*0.6); ctx.lineTo(-r*0.12,-r*0.78); ctx.stroke();
            }
          }else if(v===5){
            // Ghost icon
            ctx.translate(cx,cy);
            const r=TILE*0.34;
            ctx.fillStyle='#ffffff';
            ctx.beginPath();
            ctx.arc(0, -r*0.2, r*0.70, Math.PI, 0);
            ctx.lineTo(r*0.70, r*0.6);
            for(let i=0;i<3;i++){
              ctx.quadraticCurveTo(r*0.38-(i*0.38*r), r*0.9, r*0.1-(i*0.46*r), r*0.6);
            }
            ctx.closePath(); ctx.fill();
            ctx.strokeStyle='rgba(120,190,255,0.9)';
            ctx.lineWidth=Math.max(2,Math.floor(TILE*0.06));
            ctx.stroke();
            ctx.fillStyle='#0b0b0e';
            const eyeR = Math.max(1, TILE*0.06);
            ctx.beginPath(); ctx.arc(-r*0.25, -r*0.05, eyeR, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(r*0.25, -r*0.05, eyeR, 0, Math.PI*2); ctx.fill();
          }else{
            // Frenzy: shorter red bolt
            ctx.translate(cx,cy);
            ctx.fillStyle='#ff3a3a';
            ctx.strokeStyle='#ffffff';
            ctx.lineWidth=Math.max(2, Math.floor(TILE*0.08));
            ctx.beginPath();
            ctx.moveTo(-TILE*0.08, -TILE*0.30);
            ctx.lineTo(TILE*0.08, -TILE*0.06);
            ctx.lineTo(-TILE*0.02, -TILE*0.06);
            ctx.lineTo(TILE*0.10, TILE*0.26);
            ctx.lineTo(-TILE*0.08, TILE*0.04);
            ctx.lineTo(TILE*0.02, TILE*0.04);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
          }
          ctx.restore();
        }
      }
    }

    // Player visuals
    function drawPlayer(){
      const activePU = (freezeTimer>0 || invulnTimer>0 || frenzyTimer>0);

      const panicThreshold = player.radius*2*3;
      let minDist = Infinity;
      for(const g of enemies){
        if(g.state!=='alive') continue;
        const d = Math.hypot((g.x-player.x),(g.y-player.y));
        if(d < minDist) minDist = d;
      }
      const panic = !activePU && hasMoved && minDist < panicThreshold;
      const panicAmt = panic ? clamp(panicThreshold - minDist, 0, panicThreshold) / panicThreshold : 0;

      const now = performance.now();
      const stationary = (player.dir.x===0 && player.dir.y===0);
      const idleBounceActive = hasMoved && stationary && (now - lastCommandMs > 2500);
      const bounce = idleBounceActive ? Math.sin(animT*5.2) * TILE*0.06 : 0;

      let px = player.x*TILE, py = player.y*TILE + bounce;
      const r=player.radius*TILE;

      // Freeze aura (thicker) + snowy particles
      if(freezeTimer>0){
        const tNorm = 1 - (freezeTimer/11);
        const speed = lerp(1.2, 12.0, tNorm);
        const rad = r*1.15 + Math.sin(animT*speed)*r*0.1;
        ctx.save();
        ctx.strokeStyle='rgba(160,220,255,0.98)';
        ctx.lineWidth=Math.max(3,Math.floor(TILE*0.14));
        ctx.beginPath(); ctx.arc(px,py,rad,0,Math.PI*2); ctx.stroke();
        ctx.restore();

        if(freezeFlakes.length){
          ctx.save();
          for(const f of freezeFlakes){
            const alpha = 1 - (f.age/f.life);
            ctx.fillStyle = `rgba(220,245,255,${alpha})`;
            ctx.beginPath();
            ctx.arc(f.x*TILE, f.y*TILE, f.size*alpha, 0, Math.PI*2);
            ctx.fill();
          }
          ctx.restore();
        }
      }

      // Frenzy aura
      if(frenzyTimer>0){
        ctx.save();
        const flash = 0.7 + 0.3*Math.sin(animT*16);
        ctx.shadowColor='rgba(255,65,65,0.8)';
        ctx.shadowBlur=Math.max(2, TILE*0.25);
        ctx.strokeStyle=`rgba(255,65,65,${flash})`;
        ctx.lineWidth=Math.max(3,Math.floor(TILE*0.14));
        ctx.beginPath(); ctx.arc(px,py,r*1.28,0,Math.PI*2); ctx.stroke();
        ctx.shadowBlur=0;
        ctx.strokeStyle='rgba(255,65,65,0.98)';
        ctx.lineWidth=Math.max(2,Math.floor(TILE*0.06));
        for(let i=0;i<6;i++){
          const a = Math.random()*Math.PI*2;
          const x1=px+Math.cos(a)*r*1.30, y1=py+Math.sin(a)*r*1.30;
          const x2=px+Math.cos(a)*r*1.80, y2=py+Math.sin(a)*r*1.80;
          ctx.beginPath();
          ctx.moveTo(x1,y1);
          const mx=(x1+x2)/2 + (Math.random()-0.5)*TILE*0.18, my=(y1+y2)/2 + (Math.random()-0.5)*TILE*0.18;
          ctx.lineTo(mx,my); ctx.lineTo(x2,y2);
          ctx.stroke();
        }
        ctx.restore();
      }

      // Ghost spooky motes (subtle particles), drawn before cloak
      if(invulnTimer>0 && ghostMotes.length){
        ctx.save();
        ctx.shadowColor='rgba(140,120,255,0.45)';
        ctx.shadowBlur=Math.max(2, TILE*0.18);
        for(const m of ghostMotes){
          const alpha = 1 - (m.age/m.life);
          ctx.fillStyle = `rgba(170,160,255,${0.8*alpha})`;
          ctx.beginPath();
          ctx.arc(m.x*TILE, m.y*TILE, m.size*alpha, 0, Math.PI*2);
          ctx.fill();
        }
        ctx.restore();
      }

      // If Ghost: fully opaque cloak; no circle aura
      if(invulnTimer>0){
        const tNorm = 1 - (invulnTimer/12);
        const pulse = 0.6 + 0.4*Math.sin(animT*lerp(2.0, 9.5, tNorm));
        const dirX = clamp(player.dir.x, -1, 1);
        const sway = (-dirX)*r*0.45 + Math.sin(animT*9.0)*r*0.08;

        ctx.save();
        ctx.fillStyle = '#ffffff';
        ctx.strokeStyle = `rgba(120,190,255,${0.95*pulse})`;
        ctx.lineWidth = Math.max(2, Math.floor(TILE*0.10));

        const topR = r*1.08;
        const yTop = py - r*0.30;
        const yBottom = py + r*1.30;

        ctx.beginPath();
        ctx.arc(px, yTop, topR, Math.PI, 0, false);
        ctx.quadraticCurveTo(px+topR*1.05, yTop+topR*0.55, px+topR*0.92 + sway*0.2, yBottom - r*0.20);
        const scallops = 4;
        const width = topR*1.84;
        for(let i=scallops; i>=0; i--){
          const t = i/scallops;
          const ex = (px - width/2) + t*width + sway;
          const ey = yBottom - r*0.14 * ( (i%2) ? 1.0 : 0.55 );
          const ctrlX = ex + (i%2? -1:1)*r*0.22;
          const ctrlY = ey - r*0.22;
          ctx.quadraticCurveTo(ctrlX, ctrlY, ex, ey);
        }
        ctx.quadraticCurveTo(px-topR*1.05, yTop+topR*0.55, px-topR, yTop);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        ctx.restore();

        // Sunglasses
        const wobble = Math.sin(animT*8) * 0.05;
        const wLens = r*0.70;
        const hLens = r*0.38;
        const bridgeGap = r*0.18;
        const tilt = (player.dir.y<0? -0.18 : player.dir.y>0? 0.18 : 0) + wobble;
        ctx.save();
        ctx.translate(px, py-r*0.10);
        ctx.rotate(tilt);
        drawGlassesCentered(0,0,wLens,hLens,bridgeGap);
        ctx.restore();

        return; // skip orange body
      }

      // Normal orange body (when not ghost)
      ctx.save();
      const grad = ctx.createRadialGradient(px-r*0.4,py-r*0.4,r*0.2, px,py,r*1.2);
      grad.addColorStop(0,'#ffd79c'); grad.addColorStop(0.35,'#ffb457'); grad.addColorStop(0.7,'#ff8d1f'); grad.addColorStop(1,'#ff7a00');
      ctx.fillStyle = grad;
      ctx.beginPath(); ctx.arc(px,py,r,0,Math.PI*2); ctx.fill();
      ctx.restore();

      // leaf
      ctx.save(); ctx.translate(px+r*0.25, py-r*0.95); ctx.rotate(0.4);
      ctx.fillStyle='#44b955'; ctx.beginPath(); ctx.ellipse(0,0,r*0.6,r*0.32,0,0,Math.PI*2); ctx.fill(); ctx.restore();

      // Eyes
      const eyeY = py - r*0.10;
      const eyeOff = r*0.28;
      let eyeW = r*0.14*(1+panicAmt*0.2), eyeH = r*0.18*(1+panicAmt*0.2);
      if(frenzyTimer>0){ eyeW*=0.8; eyeH*=0.8; }
      ctx.fillStyle='#ffffff';
      ctx.beginPath(); ctx.ellipse(px-eyeOff,eyeY,eyeW,eyeH,0,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(px+eyeOff,eyeY,eyeW,eyeH,0,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='#0b0b0e';
      const pdx = clamp(player.dir.x*0.12*TILE, -r*0.08, r*0.08);
      const pdy = clamp(player.dir.y*0.12*TILE, -r*0.08, r*0.08);
      ctx.beginPath(); ctx.arc(px-eyeOff+pdx, eyeY+pdy, r*0.06, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(px+eyeOff+pdx, eyeY+pdy, r*0.06, 0, Math.PI*2); ctx.fill();

      // Mouth
      if(panic && frenzyTimer<=0){
        ctx.fillStyle='#2a0f00';
        ctx.beginPath(); ctx.ellipse(px, py+r*0.26, r*0.18*(1+panicAmt*0.35), r*0.22*(1+panicAmt*0.55), 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle='#ffb199';
        ctx.beginPath(); ctx.ellipse(px, py+r*0.31, r*0.10, r*0.11, 0, 0, Math.PI*2); ctx.fill();
      }else if(frenzyTimer>0){
        ctx.fillStyle='#2a0f00';
        ctx.beginPath(); ctx.ellipse(px, py+r*0.26, r*0.26, r*0.20, 0, 0, Math.PI*2); ctx.fill();
      }else{
        ctx.strokeStyle='#2a0f00'; ctx.lineWidth=Math.max(2,Math.floor(TILE*0.07));
        ctx.beginPath(); ctx.arc(px, py+r*0.22, r*0.20, 0.15*Math.PI, 0.85*Math.PI); ctx.stroke();
      }

      // Sunglasses
      const wobble = Math.sin(animT*8) * 0.05 * ((Math.abs(player.dir.x)+Math.abs(player.dir.y))?1:0);
      const wLens = r*0.70*(1 + panicAmt*0.08);
      const hLens = r*0.38*(1 - panicAmt*0.04);
      const bridgeGap = r*0.18;
      const tilt = (player.dir.y<0? -0.18 : player.dir.y>0? 0.18 : 0) + wobble;
      ctx.save();
      ctx.translate(px, py-r*0.10 - panicAmt*r*0.05);
      ctx.rotate(tilt);
      drawGlassesCentered(0,0,wLens,hLens,bridgeGap);
      ctx.restore();
    }

    function drawGlassesCentered(cx,cy,w,h,gap){
      const lw = Math.max(2,Math.floor(TILE*0.06));
      const left = cx - gap/2 - w/2;
      const right= cx + gap/2 + w/2;
      const y = cy;

      function lens(x){
        const sweep = (Math.sin(animT*5)+1)/2;
        const grd = ctx.createLinearGradient(x-w/2, y-h, x+w/2, y+h);
        grd.addColorStop(0, '#ff8b22');
        grd.addColorStop(sweep*0.6, '#ffc27a');
        grd.addColorStop(1, '#ff8b22');
        ctx.fillStyle=grd;
        ctx.beginPath(); ctx.ellipse(x,y,w/2,h,0,0,Math.PI*2); ctx.fill();
        ctx.lineWidth=lw; ctx.strokeStyle='#ffffff';
        ctx.beginPath(); ctx.ellipse(x,y,w/2,h,0,0,Math.PI*2); ctx.stroke();
      }
      lens(left); lens(right);
      ctx.strokeStyle='#ffffff'; ctx.lineWidth=lw;
      ctx.beginPath(); ctx.moveTo(left+w/2, y); ctx.lineTo(right-w/2, y); ctx.stroke();
    }

    // Enemies
    function drawEnemies(){
      const frozen = freezeTimer>0;
      for(const g of enemies){
        if(g.state!=='alive'){
          for(const p of g.particles){
            const x=p.x*TILE, y=p.y*TILE;
            const a = 1 - (p.age/p.life);
            ctx.fillStyle = `rgba(255,65,65,${a})`;
            ctx.beginPath(); ctx.arc(x,y,Math.max(1, TILE*0.06*a), 0, Math.PI*2); ctx.fill();
          }
          continue;
        }

        for(const p of g.particles){
          const x=p.x*TILE, y=p.y*TILE;
          const a = 1 - (p.age/p.life);
          ctx.fillStyle = `hsla(${g.auraHue},95%,65%,${a*0.8})`;
          ctx.beginPath(); ctx.arc(x,y,Math.max(1, TILE*0.06*a), 0, Math.PI*2); ctx.fill();
        }

        const x=g.x*TILE, y=g.y*TILE, r=g.radius*TILE;

        // body
        if(frozen){
          const gradI = ctx.createRadialGradient(x-r*0.4,y-r*0.4,r*0.2, x,y,r*1.1);
          gradI.addColorStop(0,'#e3f6ff'); gradI.addColorStop(1,'#7ac6ff');
          ctx.fillStyle=gradI;
        }else{
          const grad = ctx.createRadialGradient(x-r*0.4,y-r*0.4,r*0.2, x,y,r*1.1);
          grad.addColorStop(0,'#ffd89b'); grad.addColorStop(0.35,'#ffb457'); grad.addColorStop(0.7,'#ff8a1f'); grad.addColorStop(1,'#ff7a00');
          ctx.fillStyle=grad;
        }
        ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();

        // Mouth: fully closes. If frozen, keep closed (no animation).
        let openness;
        if(frozen){
          openness = 0;
        }else{
          const phase = animT*6 + g.crunchOffset;
          const cyc = 0.5 + 0.5*Math.sin(phase);
          openness = clamp(cyc * 0.52, 0, 0.52);
        }
        const mCx = x;
        const mCy = y + r*0.42;
        const mRx = r*0.56;
        const mRy = r*0.56*(openness||0);
        ctx.fillStyle=frozen?'#0f3b5a':'#1b0a00';
        if(openness < 0.03){
          ctx.strokeStyle=ctx.fillStyle;
          ctx.lineWidth = Math.max(2, Math.floor(TILE*0.06));
          ctx.beginPath(); ctx.moveTo(mCx-mRx, mCy); ctx.lineTo(mCx+mRx, mCy); ctx.stroke();
        }else{
          ctx.beginPath(); ctx.ellipse(mCx,mCy,mRx,mRy,0,0,Math.PI*2); ctx.fill();
        }

        // Angry brows (outer higher -> inner lower)
        ctx.strokeStyle=frozen?'#0f3b5a':'#3b1200';
        ctx.lineWidth=Math.max(2,Math.floor(TILE*0.07));
        ctx.beginPath(); ctx.moveTo(x - r*0.45, y - r*0.28); ctx.lineTo(x - r*0.18, y - r*0.15); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(x + r*0.45, y - r*0.28); ctx.lineTo(x + r*0.18, y - r*0.15); ctx.stroke();

        // eyes
        ctx.fillStyle='#ffffff';
        ctx.beginPath(); ctx.ellipse(x-r*0.22, y-r*0.05, r*0.12, r*0.14, 0, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(x+r*0.22, y-r*0.05, r*0.12, r*0.14, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle=frozen?'#0f3b5a':'#0b0b0e';
        const exShift = clamp(g.dir.x*0.10*TILE, -r*0.06, r*0.06);
        const eyShift = clamp(g.dir.y*0.10*TILE, -r*0.06, r*0.06);
        ctx.beginPath(); ctx.arc(x-r*0.22+exShift, y-r*0.05+eyShift, r*0.05, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(x+r*0.22+exShift, y-r*0.05+eyShift, r*0.05, 0, Math.PI*2); ctx.fill();

        // aura pulse ring
        if(!frozen && g.pulse>0){
          const a=g.pulse;
          ctx.strokeStyle=`hsla(${g.auraHue},95%,75%,${0.45*a})`;
          ctx.lineWidth=Math.max(1, TILE*0.06*a);
          ctx.beginPath(); ctx.arc(x,y,r*(1.0+0.7*(1-a)),0,Math.PI*2); ctx.stroke();
          g.pulse = Math.max(0, g.pulse - 0.03);
        }
      }
    }

    // Loop
    function loop(t){
      if(!running) return;
      const dt = Math.min(0.05, (t - lastTime)/1000);
      lastTime = t;
      animT += dt;

      if(freezeTimer>0){ freezeTimer = Math.max(0, freezeTimer - dt); if(freezeTimer===0) hudStatus.textContent=''; }
      if(invulnTimer>0){ invulnTimer = Math.max(0, invulnTimer - dt); if(invulnTimer===0){ hudStatus.textContent=''; ghostMotes.length=0; } }
      if(frenzyTimer>0){ frenzyTimer = Math.max(0, frenzyTimer - dt); if(frenzyTimer===0) hudStatus.textContent=''; }

      // Player
      player.speed = PLAYER_SPEED_TPS;
      stepEntity(player, dt);
      tryEatPellet();

      // Freeze flakes
      if(freezeTimer>0){
        if(freezeFlakes.length < 120){
          const spawn = 4;
          for(let i=0;i<spawn;i++){
            const a = Math.random()*Math.PI*2;
            const rr = player.radius*TILE*(1.0 + 0.9*Math.random());
            const vx = Math.cos(a)*(0.4+Math.random()*0.8);
            const vy = Math.sin(a)*(0.4+Math.random()*0.8) - 0.2;
            freezeFlakes.push({
              x: player.x + (rr*Math.cos(a))/TILE,
              y: player.y + (rr*Math.sin(a))/TILE,
              vx: vx/TILE,
              vy: vy/TILE,
              age: 0,
              life: 0.8 + Math.random()*0.9,
              size: Math.max(1, Math.floor(TILE*0.05 + Math.random()*TILE*0.06))
            });
          }
        }
        for(let i=freezeFlakes.length-1;i>=0;i--){
          const f = freezeFlakes[i];
          f.age += dt;
          if(f.age > f.life){ freezeFlakes.splice(i,1); continue; }
          f.vy += dt*0.10;
          f.x += f.vx*dt;
          f.y += f.vy*dt;
        }
      }else{
        freezeFlakes.length = 0;
      }

      // Ghost motes
      if(invulnTimer>0){
        if(ghostMotes.length < 90){
          const spawn = 3;
          for(let i=0;i<spawn;i++){
            const a = Math.random()*Math.PI*2;
            const rr = player.radius*TILE*(0.7 + 0.9*Math.random());
            const vx = Math.cos(a)*(0.25+Math.random()*0.4);
            const vy = Math.sin(a)*(0.25+Math.random()*0.4) - 0.1;
            ghostMotes.push({
              x: player.x + (rr*Math.cos(a))/TILE,
              y: player.y + (rr*Math.sin(a))/TILE,
              vx: vx/TILE,
              vy: vy/TILE,
              age: 0,
              life: 0.9 + Math.random()*1.0,
              size: Math.max(1, Math.floor(TILE*0.05 + Math.random()*TILE*0.05))
            });
          }
        }
        for(let i=ghostMotes.length-1;i>=0;i--){
          const m = ghostMotes[i];
          m.age += dt;
          if(m.age > m.life){ ghostMotes.splice(i,1); continue; }
          const swirl = 0.15;
          const toPlayerX = (player.x - m.x), toPlayerY = (player.y - m.y);
          m.vx += (-toPlayerY)*swirl*dt*0.2;
          m.vy += ( toPlayerX)*swirl*dt*0.2;
          m.vy -= dt*0.02;
          m.x += m.vx*dt;
          m.y += m.vy*dt;
        }
      }else{
        ghostMotes.length = 0;
      }

      // Enemies
      for(const g of enemies) stepEnemy(g, dt);

      // Collisions
      checkDeath();

      // Render
      draw();

      if(running) requestAnimationFrame(loop);
    }

    // Menu backdrop
    function drawMenuBackdrop(){
      ctx.fillStyle='#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.strokeStyle='rgba(255,122,0,.15)'; ctx.lineWidth=1;
      for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++){
        ctx.strokeRect(x*TILE,y*TILE,TILE,TILE);
      }
    }
    drawMenuBackdrop();

    // World state and game loop bootstrap
    const DIRS = { up:{x:0,y:-1}, down:{x:0,y:1}, left:{x:-1,y:0}, right:{x:1,y:0} }; // redeclared? ensure no duplicate (already above)
    // Game logic vars (declared earlier)
    let world=null, player=null, enemies=[], dotsLeft=0, openTiles=[];
    // Oops: we already declared globally above; keeping current ones.

    // Start helpers
    function startGame(resetAll=false){
      if(resetAll){ level=1; currentSeed=1; }
      loadLevel(level, level);
      running = true; lastTime = performance.now(); requestAnimationFrame(loop);
    }
    function restartSameLevel(){
      loadLevel(level, currentSeed);
      running = true; lastTime = performance.now(); requestAnimationFrame(loop);
    }
    function changeMazeSameLevel(){
      let s=currentSeed;
      do{ s = 1 + Math.floor(Math.random()*MAX_LEVEL); } while(s===currentSeed);
      loadLevel(level, s);
      running = true; lastTime = performance.now(); requestAnimationFrame(loop);
    }

    // Vars pulled up after refactor
    let level=1, currentSeed=1, running=false, lastTime=performance.now();

  })();
  </script>
</body>
</html>
